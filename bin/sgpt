#!/bin/bash
# sgpt-wrapper - Clean version that removes thinking blocks

# Version info
WRAPPER_VERSION="1.0.0"

source ~/.config/shell_gpt/.sgptrc 2>/dev/null

# Get sgpt version
get_sgpt_version() {
    ~/.local/share/pipx/venvs/shell-gpt/bin/sgpt --version 2>/dev/null || echo "unknown"
}

# Handle --menu flag - show interactive configuration menu
handle_menu() {
    local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    local install_script="$(dirname "$script_dir")/scripts/install.sh"
    
    if [ -f "$install_script" ]; then
        "$install_script" --menu
    else
        echo "Error: install.sh not found"
        exit 1
    fi
}

# Handle --uninstall flag
handle_uninstall() {
    local dry_run=false
    local clean_keys=false
    
    # Parse additional flags
    shift
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --dry-run|-d) dry_run=true ;;
            --clean-keys|-k) clean_keys=true ;;
            *) ;;
        esac
        shift
    done
    
    local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    local install_script="$(dirname "$script_dir")/scripts/install.sh"
    
    if [ -f "$install_script" ]; then
        local args=("--uninstall")
        [ "$dry_run" = true ] && args+=("--dry-run")
        [ "$clean_keys" = true ] && args+=("--clean-keys")
        "$install_script" "${args[@]}"
    else
        echo "Error: install.sh not found"
        exit 1
    fi
}

# Handle --help flag
handle_help() {
    echo "sgpt-wrapper v$WRAPPER_VERSION"
    echo ""
    echo "Usage: sgpt [options] [prompt]"
    echo ""
    echo "Wrapper Options:"
    echo "  --menu, -m           Show interactive configuration menu"
    echo "  --uninstall          Uninstall sgpt-wrapper"
    echo "  --help, -h           Show this help message"
    echo "  --version, -v        Show version information"
    echo ""
    echo "ShellGPT Options (passed through to sgpt):"
    echo "  -s, --shell              Execute shell commands"
    echo "  -c, --code              Generate code"
    echo "  -n, --no-interaction    Don't prompt for confirmation"
    echo "  --system-prompt, -sp    Set system prompt"
    echo "  --role <name>           Use predefined role"
    echo "  --chat <name>           Continue chat session"
    echo "  --list-roles            List available roles"
    echo "  --list-chats            List chat sessions"
    echo ""
    echo "Examples:"
    echo "  sgpt 'What is the weather?'"
    echo "  sgpt --shell 'Find large files'"
    echo "  sgpt --code 'Write a Fibonacci function'"
    echo "  sgpt --role senior-dev 'Explain REST APIs'"
    echo ""
    echo "For full sgpt options, run: ~/.local/share/pipx/venvs/shell-gpt/bin/sgpt --help"
    echo ""
    echo "Configuration:"
    echo "  Config: ~/.config/shell_gpt/.sgptrc"
    echo "  API Keys: ~/.local/share/sgpt/auth.json"
}

# Handle --version flag
handle_version() {
    local sgpt_ver
    sgpt_ver=$(get_sgpt_version)
    echo "sgpt-wrapper v$WRAPPER_VERSION | sgpt v$sgpt_ver"
}

get_shell_mode() {
    [ "$DEFAULT_EXECUTE_SHELL_CMD" = "true" ] && echo "execute" || echo "clipboard"
}

build_prompt() {
    local user_prompt="$1"
    local system_prompt=""
    
    # Check for --system-prompt flag in arguments
    shift
    local args=("$@")
    for arg in "${args[@]}"; do
        if [ "$prev_arg" = "--system-prompt" ] || [ "$prev_arg" = "-sp" ]; then
            system_prompt="$arg"
            break
        fi
        prev_arg="$arg"
    done
    
    # Fall back to config variable if no flag provided
    if [ -z "$system_prompt" ] && [ -n "$WRAPPER_SYSTEM_PROMPT" ]; then
        system_prompt="$WRAPPER_SYSTEM_PROMPT"
    fi
    
    # Return combined prompt or original if no system prompt
    if [ -n "$system_prompt" ]; then
        echo "System: $system_prompt
User: $user_prompt"
    else
        echo "$user_prompt"
    fi
}

extract_command() {
    perl -pe 's/<think>.*?<\/think>//g' | grep -v '^$' | grep -v 'Warning' | grep -v '^Thinking:' | tail -1
}

handle_shell() {
    local no_interaction=""
    local prompt=""
    local system_prompt=""
    local args=("$@")
    
    for arg in "${args[@]}"; do
        case "$arg" in
            --no-interaction|-n) no_interaction="yes" ;;
            --system-prompt|-sp) ;;
            *)
                if [ "$prev_arg" = "--system-prompt" ] || [ "$prev_arg" = "-sp" ]; then
                    system_prompt="$arg"
                else
                    prompt="${prompt}${prompt:+ }${arg}"
                fi
                ;;
        esac
        prev_arg="$arg"
    done
    
    prompt=$(echo "$prompt" | sed 's/^ *| *$//')
    
    # Build combined prompt if system prompt is set
    if [ -n "$system_prompt" ]; then
        prompt="System: $system_prompt
User: $prompt"
    elif [ -n "$WRAPPER_SYSTEM_PROMPT" ]; then
        prompt="System: $WRAPPER_SYSTEM_PROMPT
User: $prompt"
    fi
    
    raw_output=$(~/.local/share/pipx/venvs/shell-gpt/bin/sgpt --shell --no-interaction "$prompt" 2>&1)
    cmd=$(echo "$raw_output" | extract_command)
    
    [ -z "$cmd" ] && echo "Error: No command extracted" && return 1
    
    
    if [ -n "$no_interaction" ]; then
        if [ "$(get_shell_mode)" = "execute" ]; then
            # echo "âš¡ Executing: $cmd"
            eval "$cmd"
        else
            # echo "ðŸ“‹ Copied: $cmd"
            echo "$cmd" | xclip -selection clipboard 2>/dev/null || echo "$cmd"
        fi
    else
        if [ "$(get_shell_mode)" = "execute" ]; then
            echo "âš¡ Executing: $cmd"
            eval "$cmd"
        else
            echo ""
            echo "Command: $cmd"
            echo ""
            echo "[E]xecute, [M]odify, [D]escribe, [A]bort: "
            read choice
            case "$choice" in
                e|E) eval "$cmd" ;;
                m|M) if command -v xclip >/dev/null; then
                         echo "$cmd" | xclip -selection clipboard >/dev/null 2>&1
                     elif command -v xsel >/dev/null; then
                          echo "$cmd" | xsel --clipboard >/dev/null 2>&1
                     else
                         echo "$cmd"
                     fi;;
                d|D) ~/.local/share/pipx/venvs/shell-gpt/bin/sgpt --describe-shell "$cmd" ;;
                *) echo "Aborted" ;;
            esac
        fi
    fi
}

handle_code() {
    local prompt="$*"
    local system_prompt=""
    local args=("$@")
    
    # Extract system prompt from arguments
    for arg in "${args[@]}"; do
        if [ "$prev_arg" = "--system-prompt" ] || [ "$prev_arg" = "-sp" ]; then
            system_prompt="$arg"
            break
        fi
        prev_arg="$arg"
    done
    
    # Build combined prompt if system prompt is set
    if [ -n "$system_prompt" ]; then
        prompt="System: $system_prompt
User: $prompt"
    elif [ -n "$WRAPPER_SYSTEM_PROMPT" ]; then
        prompt="System: $WRAPPER_SYSTEM_PROMPT
User: $prompt"
    fi
    
    local code=$(~/.local/share/pipx/venvs/shell-gpt/bin/sgpt --code "$prompt" 2>&1)
    code=$(echo "$code" | grep -v "Warning:" | tr -d '\r')
    
    echo ""
    echo "Generated code:"
    echo "$code"
    echo ""
    echo "ðŸ“‹ Copied to clipboard"
    echo "$code" | xclip -selection clipboard 2>/dev/null || echo "$code" | xsel --clipboard 2>/dev/null || echo "$code"
}

case "$1" in
    -m|--menu) shift; handle_menu "$@" ;;
    --uninstall) shift; handle_uninstall "$@" ;;
    -h|--help) handle_help ;;
    -v|--version) handle_version ;;
    -s|--shell) shift; handle_shell "$@" ;;
    -c|--code) shift; handle_code "$@" ;;
    *) ~/.local/share/pipx/venvs/shell-gpt/bin/sgpt "$@" ;;
esac
